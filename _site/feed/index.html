<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>海涛</title>
    <link href="/feed/" rel="self" />
    <link href="http://geeklu.com" />
    <lastBuildDate>2013-08-31T15:06:27+08:00</lastBuildDate>
    <webMaster>kejinlu@gmail.com</webMaster>
    
    <item>
      <title>阿里巴巴搜索技术总结</title>
      <link href="/2013/08/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
      <pubDate>2013-08-28T00:00:00+08:00</pubDate>
      <author>海涛</author>
      <guid>/2013/08/阿里巴巴搜索技术总结</guid>
      <content:encoded><![CDATA[<hr />

<h1>阿里巴巴搜索引擎技术大讲堂</h1>

<p> 今天结束了阿里巴巴<strong>搜索引擎</strong>的课程学习，通过两天的课程我可以说收获很多。 这也是我第一次用md语言来写博客。有点小兴奋哦，记录下时间，现在时刻是2013-08-28：23：26。呵呵</p>

<hr />

<h2>正文</h2>

<p> <strong>1，了解了阿里巴巴的搜索技术框架和各个细节。<br/>
2，了解了一个武侠公司的文化。<br/>
   3，对自己的兴趣爱好又有了更深入的了解，如：我知道了自己很喜欢架构这个东西。</strong></p>

<hr />

<h2>课程介绍</h2>

<hr />

<h3>1.1 一淘购物搜索全貌*一泉</h3>

<h3>1.2 全网商品Spider系统的关键技术*飘羽</h3>

<h3>1.3 基于Hadopp/HBase的一淘搜索离线系统*瓦力</h3>

<h3>1.4 商品检索引擎的关键技术*孝杰</h3>

<h3>1.5 Query的旅行--淘宝搜索在线系统*亚夫</h3>

<h3>2.1 啊里中文分词系统及电子商务环境中的文本挖掘*水德</h3>

<h3>2.2 淘宝个性化搜索*公达</h3>

<h3>2.3 一淘商品搜索相关性*亦飞</h3>

<h3>2.4 一淘产品库*倪完</h3>

<hr />
]]></content:encoded>
    </item>
    
    <item>
      <title>搜索全貌</title>
      <link href="/2013/08/%E6%90%9C%E7%B4%A2%E5%85%A8%E8%B2%8C/"/>
      <pubDate>2013-08-27T00:00:00+08:00</pubDate>
      <author>海涛</author>
      <guid>/2013/08/搜索全貌</guid>
      <content:encoded><![CDATA[<hr />

<h1>一淘搜索全貌</h1>

<p>一淘是整个啊里的搜索技术支持。</p>

<hr />

<h2>系统</h2>

<p>啊里整个搜索引擎可以分为四个部分。<br/>
1. <strong>引擎在线系统</strong>数千台服务器中美两地部署<br/>
2. <strong>Hadoop/Hbase离线集群</strong>规模和应用方式业界领先<br/>
3. <strong>商品快速更新</strong>能做到淘系/B2C商品信息变化在100s内更新到引擎<br/>
4. <strong>平台化/集中运维</strong>全系统平台化，开发成功共享，统一集中管理。</p>

<p>一淘搜索从2010年起步，到2011年部署hadoop/HBase（150台）到2013年的330台集群，更新率99.04%。</p>

<p>好了说了这么非技术的东西，现在上一个一淘搜索系统系统图
<img src="http://lgo.me/images/2013/08/29/IMG_20130827_103801.jpg" alt="enter image description here" /></p>

<p>从上图可以看出，存储系统的数据来源是分为外网抓取和淘宝商品库直接导入得来的。
有了大数据，下一步是进行“大数据处理”，接下来就是建立索引进行搜索了。</p>

<p><img src="http://hi.csdn.net/attachment/201108/20/0_1313816866b9b9.gif" alt="enter image description here" /></p>

<p>好的，如上图所示，我们可以看到，淘宝的海量数据产品技术架构，分为以下五个层次，从上至下来看，它们分别是：数据源，计算层，存储层，查询层和产品层。
这就是淘宝整个系统架构。</p>

<h4>我重点了解了</h4>

<p>QP： query planer 的作用。它是负责前台与后台传话。<br/>
Forest 内幕属性转化模块（主要负责前台的文本信息转换成数字标签）。</p>

<blockquote><p>用户输入查询词后，qp经过一定的分析，解析出后台应该可以识别的词。
这样Forest就可以将这些词，抓换成数字查询（数据库里商品的属性都是用数字来存储的，而建立这些数字与文字的对应关系的模块就是forest）。
转换的原因很容易想到，是因为数据库里面对整型数字的操作速度要方便快捷。</p></blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>程序崩溃的原因</title>
      <link href="/2013/06/%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <pubDate>2013-06-09T00:00:00+08:00</pubDate>
      <author>海涛</author>
      <guid>/2013/06/程序崩溃的原因</guid>
      <content:encoded><![CDATA[<h1>如果程序崩溃，可能的原因是什么？</h1>

<p>You are given the source to an application which crashes when it is run. After running
it ten times in a debugger, you find it never crashes in the same place. The application
is single threaded, and uses only the C standard library. What programming errors
could be causing this crash? How would you test each one?</p>

<p>大意：你得到一个应用的源码，该应用每次启动都会出现程序崩溃。再你调试了10次后发现，在一个相同的条件下，该程序从不崩溃。  该程序是单线程，并且使用的库函数是c的标准库。那么，该程序崩溃的原因是什么？你怎样检测它呢？</p>

<p>The question largely depends on the type of application being diagnosed. However, we can
give some general causes of random crashes.
1. Random variable: The application uses some random number or variable component
   which may not be fixed for every execution of the program. Examples include: user
  input, a random number generated by the program, or the time of day.
2. Memory Leak: The program may have run out of memory. Other culprits are totally
   random for each run since it depends on the number of processes running at that
  particular time. This also includes heap overflow or corruption of data on the stack.
It is also possible that the program depends on another application / external module that
could lead to the crash. If our application, for example, depends on some system attributes
and they are modified by another program, then this interference may lead to a crash. Pro-
grams which interact with hardware are more prone to these errors.
In an interview, we should ask about which kind of application is being run. This information
may give you some idea about the kind of error the interviewer is looking for. For example,
a web server is more prone to memory leakage, whereas a program that runs close to the
system level is more prone to crashes due to system dependencies.</p>

<p>答案：该问题很大程度上取决于对该应用的诊断。但我们可以总结一下一些随机常见的崩溃原因：</p>

<ol>
<li>不确定的变量：程序使用了随机的数字或变量组件，在程序执行时没有被很好的确定范围。如：用户输入，随机数，或时间。</li>
</ol>


<p>2.内存泄漏：程序每次执行时都内存溢出。每次运行程序崩溃的罪魁祸首是随机的，因为它依赖于在特定时间运行的进程数。</p>

<p>包括堆溢出或者是栈异常。
程序依赖于其它外部应用也可能导致崩溃。如果我们的应用依赖于一个系统某些系统属性，他们被另一个程序修改，那么这个干扰可能会导致系统崩溃。与硬件交互的程序更容易出现这些错误。例如，一个Web服务器是更容易出现内存泄漏，而接近系统级运行的程序更容易崩溃，由于系统的依赖。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>自动后台运行脱离终端的程序</title>
      <link href="/2013/05/%E8%87%AA%E5%8A%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%84%B1%E7%A6%BB%E7%BB%88%E7%AB%AF%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <pubDate>2013-05-06T00:00:00+08:00</pubDate>
      <author>海涛</author>
      <guid>/2013/05/自动后台运行脱离终端的程序</guid>
      <content:encoded><![CDATA[<h1>linux下程序自动后台运行，脱离终端</h1>

<p>看sipp的源代码，看到里面有实现完全后台运行，即脱离了终端。不向终端打印任何信息。<br/>
这在写后台程序时是很有帮助的。有时我们为了提高程序性能，会禁止程序与终端的io输出。</p>

<p>代码如下：</p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdlib.h&gt;
#define BUFFER_SIZE 1024

int main(int argc, char *argv[])
{
//  return 0;
        pid_t l_pid;
        switch(l_pid = fork())
        {
            case -1:
                // error when forking !
                printf("Forking error");
                exit(-1);
            case 0:
                // child process - poursuing the execution
                // close all of our file descriptors
                {
                    int nullfd = open("/dev/null", O_RDWR);

                    dup2(nullfd, fileno(stdin));
                    dup2(nullfd, fileno(stdout));
                    dup2(nullfd, fileno(stderr));
                    //sleep(100);

                    close(nullfd);
                }
                break;
            default:
                // parent process - killing the parent - the child get the parent pid
                printf("Background mode - PID=[%d]\n", l_pid);
                exit(1);
        }
                printf("Background mode - PID=[%d]\n", l_pid);
                    sleep(100);
}
</code></pre>

<p>关闭了stdin stdout stderr，而父进程在exit(1)处结束，而子进程继续执行下面的sleep等代码。</p>

<p>/dev/null可以看作"黑洞". 它非常等价于一个只写文件. 所有写入它的内容都会永远丢失. 而尝试从它那儿读取内容则什么也读不到. <br/>
 /dev/null对命令行和脚本也非常的有用.</p>

<p>The function fileno() examines the  argument  stream  and  returns  its
       integer descriptor.</p>

<p><strong>dup2</strong></p>

<p> dup2() makes newfd be the copy of oldfd, closing newfd first if  neces‐
       sary, but note the following:</p>

<p>If  oldfd  is  not a valid file descriptor, then the call fails, and
          newfd is not closed.</p>

<pre><code>   *  If oldfd is a valid file descriptor, and newfd has the same value as
      oldfd, then dup2() does nothing, and returns newfd.
</code></pre>

<p>解释下：fileno只是读取FILE *或流的int标志。</p>

<pre><code>         dup2 原型是：int dup2(int oldfd, int newfd); 将newfd是oldfd的一个拷贝，如果newfd打开，则先关闭它。
</code></pre>

<p>有了这些注释，就可以完全看懂上面的代码了。。。该程序已经用到了一个项目中。:-)</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Sipp代码中的多线程技巧</title>
      <link href="/2013/05/sipp%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
      <pubDate>2013-05-05T00:00:00+08:00</pubDate>
      <author>海涛</author>
      <guid>/2013/05/sipp代码中的多线程技巧</guid>
      <content:encoded><![CDATA[<h1>linux下程序自动后台运行，脱离终端</h1>

<p>sipp是一个大话务量的sip模拟软件。既然是大话务量，那他对多进程的控制必然非常优秀。这也成是我研究这款软件的主要原因，<strong>立志成为能设计出这样系统的男人</strong>。</p>

<h3>1.两次fork</h3>

<blockquote><p>注意fork时用的是switch而不是if判断。</p></blockquote>

<p>代码如下：</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
int main()
{
    pid_t  l_pid;
    char x[100]= "ls";
    switch(l_pid = fork()) // fork 1
    {
        case -1:
            // error when forking !
            printf("Forking error main");
            break;

        case 0:
            // first child process - execute the command
            if((l_pid = fork()) &lt; 0) {  // fork 2
                printf("Forking error child");
            } else {
                if( l_pid == 0){
                    int ret;
                    ret = system("./time"); // second child runs
                    if(ret == -1) {
                        printf("system call error for %s",x);
                    }
                }
                exit(-1); 
            }
            break;
        default:
            // parent process continue
            // reap first child immediately
            pid_t ret;
            while ((ret=waitpid(l_pid, NULL, 0)) != l_pid) { //接收 fork 1
                if (ret != -1) {
                    printf("waitpid returns %1d for child %1d",ret,l_pid);
                }
            }
            break;
    }
}
</code></pre>

<p>概念澄清：<br/>
<strong>僵尸进程</strong>->当子进程exit时会向其父进程发送我已经“死了”的SIGCHILD信号，父进程有两种处理办法:</p>

<blockquote><p>1.waitpid接收SIGCHILD信号，从而回收子进程资源。<br/>
2.未做任何处理。此时，默认忽略该信号使子进程成为僵尸，只有当父进程exit后，才由系统回收所有资源。<br/>
想想看，如果父进程是个死循环，一直这样进行下去呢？僵尸会越来越多。</p></blockquote>

<p><img src="http://blog.csdn.net/sky04/article/details/6338400" alt="enter image description here" /></p>

<p><strong>孤儿进程</strong>->当父亲进程先exit，则子进程成为孤儿进程，由系统init进程收养。这样孤儿会在结束时，由系统直接回收。</p>

<p>fork了两次，造出一个中间父进程。使爷爷进程接受fork1的结束信号，并回收其资源。这样，fork2就成了孤儿进程，结束时不会变为僵尸进程了。否则，sipp这样的多进程软件，肯定会产生很多僵尸，从而对资源造成大量的浪费。</p>

<p><img src="http://hi.csdn.net/attachment/201108/11/0_1313067258aapH.gif" alt="enter image description here" /></p>

<h2>线程间依赖启动----信号和槽</h2>

<p>其实信号和槽的概念来源与QT，简单来说是一个线程制造了一个槽，这个槽使用来接收信号的。
当另一个线程到达某一条件后，发出该槽的信号，带槽的线程就可以运行槽函数了。</p>

<p>《《在开发一个复杂工程的时候，经常会遇到这样一个问题：整个系统被分成数个模块，每个模块提供有限的功能，由上层调用组成整个系统，为了保证每个模块的独立性，我们经常会尽量限制模块与模块之间的直接联系，比如每个模块只提供有限的API或者COM接口，而内部实现则完全封闭起来。 但有的时候会出一些设计要求，必须能够使模块之间能够直接通讯，而这两个模块往往处于不同的逻辑层次，之间相差甚远，如何设计它们之间的调用模式使整个工程维持整洁变得非常困难，比如模块直接直接包含对方的头文件会引起编译变得复杂，提供api或者接口会引起版本危机等问题。 sigslot的出现为我们提供了一种解决问题的思想，它用“信号”的概念实现不同模块之间的传输问题，sigslot本身类似于一条通讯电缆，两端提供发送器和接收器，只要把两个模块用这条电缆连接起来就可以实现接口调用，而sigslot本身只是一个轻量级的作品，整个库只有一个.h文件，所以无论处于何种层次的库，都可以非常方便的包含它。 举个例子，我们设计一个发送消息的类，这个类负责在某种时刻向外界发出求救信号:》》<a href="http://blog.csdn.net/sky04/article/details/6338400">引用</a> &lt;---</p>

<p>信号和槽的概念解决了 低耦合和高内聚。使得模块间的耦合度降低。</p>

<p>下面的代码使用了Sigslot，Sigslot是一个小巧的框架，很好封装了信号和槽。推荐使用！！！</p>

<pre><code>/*
   功能，Sigslot入门
   日期，2012年7月1日
   */
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include "sigslot.h"

using namespace std;
using namespace sigslot;

class ThreadMutex 
{
    private:
    pthread_mutex_t mtx;
    public:
    ThreadMutex()
    {
        pthread_mutex_init(&amp;mtx,NULL);
    }
    ~ThreadMutex()
    {
        pthread_mutex_destroy( &amp;mtx );
    }
    inline void lock()
    {
        pthread_mutex_lock( &amp;mtx );
    }
    inline void unlock()
    {
        pthread_mutex_unlock( &amp;mtx );
    }
};

class Location
{
    private:
        //pthread_t threadmy;
    public:
        // 在这里指定信号，这里的信号是不带参数的，signaln表示带几个参数，后面将会用
        // 这个信号与指定的槽进行绑定的。
        signal0&lt;&gt; ToSniffer;
        Location()
        {
            printf("Location is started!\n"); 
        }
        void startLoc()
        {
            cout &lt;&lt; "开始11" &lt;&lt; endl;
            ToSniffer();
            sleep(1);
            cout &lt;&lt; "结束11" &lt;&lt; endl;
        }
};
class Topocation
{
    private:
        //pthread_t threadmy;
    public:
        // 在这里指定信号，这里的信号是不带参数的，signaln表示带几个参数，后面将会用
        // 这个信号与指定的槽进行绑定的。
        signal0&lt;&gt; ToSniffer;
        Topocation()
        {
            printf("Topocation is started!\n"); 
        }
        void startTopo()
        {
            cout &lt;&lt; "开始2" &lt;&lt; endl;
            ToSniffer();
            sleep(1);
            cout &lt;&lt; "结束2" &lt;&lt; endl;
        }

        // 继承 has_slots&lt;&gt; ，表示拥有响应信号的槽
};
class Sniffer : public has_slots&lt;&gt;
{
    public:
        Sniffer()
        {
        }
        // 作为信号响应的槽
        void startSniffer()
        {
            m_tx.lock();
            cout &lt;&lt; "开始探测！ " &lt;&lt; b_state &lt;&lt; endl;
            sleep(3);
            cout &lt;&lt;"探测结束" &lt;&lt; endl;
            m_tx.unlock();
        }
    private:
        bool b_state;
        ThreadMutex m_tx;
};
class Control
{
    private:
        pthread_t mythread;
    public:
        Sniffer mysniffer;
        Location myLoc;
        Topocation myTopo;
        Control()
        {
            myLoc.ToSniffer.connect(&amp;mysniffer,&amp;Sniffer::startSniffer);
            myTopo.ToSniffer.connect(&amp;mysniffer,&amp;Sniffer::startSniffer);
        }
        void controlsend()
        {
            int ret;
            //void *startFunc1(void *a);
            //void *p = (void *)a;
        void * startFunc1(void * tmp);
        void * startFunc2(void * tmp);
            ret = pthread_create(&amp;mythread,NULL,startFunc1,this);
            ret = pthread_create(&amp;mythread,NULL,startFunc2,this);
            if(ret &lt; 0)
                printf("thread create wrong!\n");
        }
};
        void * startFunc1(void * tmp)
        {
                Control * p = (Control *)tmp;
                    p -&gt;myLoc.startLoc();
        }
        void * startFunc2(void * tmp)
        {
                Control * p = (Control *)tmp;
                p -&gt; myTopo.startTopo();
        }
int main()
{

    int ret;
    Control mycontrol;
    mycontrol.controlsend();
    while(1);
    return 0;
}
</code></pre>

<p>Sniffer实现了 “槽” --- 即响应函数。<br/>
signal0&lt;> ToSniffer;<br/>
// 在这里指定信号，这里的信号是不带参数的，signaln表示带几个参数，后面将会用<br/>
        // 这个信号与指定的槽进行绑定的。
具体的用法可以查阅</p>

<pre><code>Sniffer mysniffer;
        Location myLoc;
        Topocation myTopo;
        Control()
        {
            myLoc.ToSniffer.connect(&amp;mysniffer,&amp;Sniffer::startSniffer);
            myTopo.ToSniffer.connect(&amp;mysniffer,&amp;Sniffer::startSniffer);
        }
</code></pre>

<p>在这里建立了链接。</p>

<p>可以用来实现 模块A 和B 调用公共模块。模块间省去了 用while循环的方式被动的接受命令，而是主动相应。while死循环的方式无疑是浪费cpu，而信号量的方式，又显得不够灵魂。
<strong>其实Sigslot也是封装了 观察者模式。</strong>这里需要特别注意拉。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Sipp代码中时间打印</title>
      <link href="/2013/05/sipp%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%97%B6%E9%97%B4%E6%89%93%E5%8D%B0/"/>
      <pubDate>2013-05-05T00:00:00+08:00</pubDate>
      <author>海涛</author>
      <guid>/2013/05/sipp代码中时间打印</guid>
      <content:encoded><![CDATA[<h1>c语言获取时间</h1>

<p>代码如下：</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
using namespace std;

char* formatTime (struct timeval* P_tv, bool microseconds)
{
  static char L_time [50];
  struct tm * L_currentDate;

  // Get the current date and time
  time(&amp;P_tv-&gt;tv_sec);
  L_currentDate = localtime ((const time_t *)&amp;P_tv-&gt;tv_sec);

  // Format the time
  if (L_currentDate == NULL)
    {
      memset (L_time, 0, 50);
    } 
  else
    {
 if (microseconds) {
   sprintf(L_time, "%4.4d-%2.2d-%2.2d %2.2d:%2.2d:%2.2d:%03.03f",
       L_currentDate-&gt;tm_year + 1900,
       L_currentDate-&gt;tm_mon + 1,
       L_currentDate-&gt;tm_mday,
       L_currentDate-&gt;tm_hour,
       L_currentDate-&gt;tm_min,
       L_currentDate-&gt;tm_sec,
       (double)P_tv-&gt;tv_usec/(double)1000.0);
 } else {
          sprintf(L_time, "%4.4d-%2.2d-%2.2d/t%2.2d:%2.2d:%2.2d:%3.3d/t%10.10d.%6.6d",
       L_currentDate-&gt;tm_year + 1900,
       L_currentDate-&gt;tm_mon + 1,
       L_currentDate-&gt;tm_mday,
       L_currentDate-&gt;tm_hour,
       L_currentDate-&gt;tm_min,
       L_currentDate-&gt;tm_sec,
              (int) (P_tv-&gt;tv_usec)/1000,
              (long) (P_tv-&gt;tv_sec),
              (long) (P_tv-&gt;tv_usec));       
 }
    }
  return (L_time);
} /* end of formatTime */

int main()
{
    struct timeval currenttime;
    printf("%s\n",formatTime(&amp;currenttime,true));
    sleep(5);
    printf("%s\n",formatTime(&amp;currenttime,true));
}
</code></pre>

<p>输出时间：
2013-05-05 21:12:48:-1217089.548
2013-05-05 21:12:53:-1217089.548
精确计算了时间。</p>

<blockquote><p>有时间再扩展，做更深入的解释。</p></blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Tmp</title>
      <link href="/2013/03/tmp/"/>
      <pubDate>2013-03-31T00:00:00+08:00</pubDate>
      <author>海涛</author>
      <guid>/2013/03/tmp</guid>
      <content:encoded><![CDATA[
]]></content:encoded>
    </item>
    
    <item>
      <title>Linux_c++限时输入</title>
      <link href="/2013/03/linux_C%2B%2B%E9%99%90%E6%97%B6%E8%BE%93%E5%85%A5/"/>
      <pubDate>2013-03-31T00:00:00+08:00</pubDate>
      <author>海涛</author>
      <guid>/2013/03/linux_C++限时输入</guid>
      <content:encoded><![CDATA[<h2>linux c++ 限时输入</h2>

<p>今天在论坛是看到一个需求：在终端限时输入的问题。<br/>
自己了找代码：</p>

<pre><code>#include&lt;unistd.h&gt;
#include&lt;signal.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;setjmp.h&gt;

#define MAXLINE 4096

static void sig_alrm(int);

static jmp_buf env_alrm;

int main(void)
{
        int n;
        char line[MAXLINE];

        if(signal(SIGALRM, sig_alrm) == SIG_ERR)
                printf("signal(SIGALRM) error!\n");
    if(setjmp(env_alrm) != 0)
    {
        printf("read timeout!\n");
        return -1;
    }
        alarm(10);
        //这里存在竞争条件
        //依赖 中断的系统调用， 如果系统自动重启系统调用，则无效
        if((n = read(STDIN_FILENO, line, MAXLINE)) &lt; 0)
                printf("read error");
        alarm(0);//如果读到数据则立即结束。

        write(STDOUT_FILENO, line, n);
        return 0;
}

static void sig_alrm(int signo)
{
        //do nothing
        longjmp(env_alrm,1);
        printf("sig_alrm!");
}
</code></pre>

<p><strong>函数原型：
int setjmp(jmp_buf envbuf);</strong><br/>
setjmp函数用缓冲区envbuf保存系统堆栈的内容，以便后续的longjmp函数使用。setjmp函数初次启用时返回0值。</p>

<p><strong>void longjmp(jmp_buf envbuf, int val);</strong><br/>
longjmp函数中的参数envbuf是由setjmp函数所保存的堆栈环境，参数val设置setjmp函数的返回值。longjmp函数本身是没有返回值的，它执行后跳转到保存envbuf参数的setjmp函数调用，并由setjmp函数调用返回，此时setjmp函数的返回值就是val。</p>

<p>调用longjmp函数时不能使setjmp函数返回０，如果val为0，则setjmp函数返回１。longjmp函数从来不返回，因为它调用后就跳转到setjmp函数保存的堆栈处，恢复堆栈开始执行，所以longjmp函数不会返回。</p>

<p>例子用到了 alarm 定时器函数。指向sig_alrm().定时器函数，是用来定时发送信号的。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>线程间的依赖启动  信号和槽</title>
      <link href="/2012/07/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96%E5%90%AF%E5%8A%A8--%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/"/>
      <pubDate>2012-07-22T00:00:00+08:00</pubDate>
      <author>海涛</author>
      <guid>/2012/07/线程间的依赖启动--信号和槽</guid>
      <content:encoded><![CDATA[<h2>线程间依赖启动----信号和槽</h2>

<p>其实信号和槽的概念来源与QT，简单来说是一个线程制造了一个槽，这个槽使用来接收信号的。
当另一个线程到达某一条件后，发出该槽的信号，带槽的线程就可以运行槽函数了。</p>

<p>《《在开发一个复杂工程的时候，经常会遇到这样一个问题：整个系统被分成数个模块，每个模块提供有限的功能，由上层调用组成整个系统，为了保证每个模块的独立性，我们经常会尽量限制模块与模块之间的直接联系，比如每个模块只提供有限的API或者COM接口，而内部实现则完全封闭起来。 但有的时候会出一些设计要求，必须能够使模块之间能够直接通讯，而这两个模块往往处于不同的逻辑层次，之间相差甚远，如何设计它们之间的调用模式使整个工程维持整洁变得非常困难，比如模块直接直接包含对方的头文件会引起编译变得复杂，提供api或者接口会引起版本危机等问题。 sigslot的出现为我们提供了一种解决问题的思想，它用“信号”的概念实现不同模块之间的传输问题，sigslot本身类似于一条通讯电缆，两端提供发送器和接收器，只要把两个模块用这条电缆连接起来就可以实现接口调用，而sigslot本身只是一个轻量级的作品，整个库只有一个.h文件，所以无论处于何种层次的库，都可以非常方便的包含它。 举个例子，我们设计一个发送消息的类，这个类负责在某种时刻向外界发出求救信号:》》<a href="http://blog.csdn.net/sky04/article/details/6338400">引用</a> &lt;---</p>

<p>信号和槽的概念解决了 低耦合和高内聚。使得模块间的耦合度降低。</p>

<p>下面的代码使用了Sigslot，Sigslot是一个小巧的框架，很好封装了信号和槽。推荐使用！！！</p>

<pre><code>/*
   功能，Sigslot入门
   日期，2012年7月1日
   */
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include "sigslot.h"

using namespace std;
using namespace sigslot;

class ThreadMutex 
{
    private:
    pthread_mutex_t mtx;
    public:
    ThreadMutex()
    {
        pthread_mutex_init(&amp;mtx,NULL);
    }
    ~ThreadMutex()
    {
        pthread_mutex_destroy( &amp;mtx );
    }
    inline void lock()
    {
        pthread_mutex_lock( &amp;mtx );
    }
    inline void unlock()
    {
        pthread_mutex_unlock( &amp;mtx );
    }
};

class Location
{
    private:
        //pthread_t threadmy;
    public:
        // 在这里指定信号，这里的信号是不带参数的，signaln表示带几个参数，后面将会用
        // 这个信号与指定的槽进行绑定的。
        signal0&lt;&gt; ToSniffer;
        Location()
        {
            printf("Location is started!\n"); 
        }
        void startLoc()
        {
            cout &lt;&lt; "开始11" &lt;&lt; endl;
            ToSniffer();
            sleep(1);
            cout &lt;&lt; "结束11" &lt;&lt; endl;
        }
};
class Topocation
{
    private:
        //pthread_t threadmy;
    public:
        // 在这里指定信号，这里的信号是不带参数的，signaln表示带几个参数，后面将会用
        // 这个信号与指定的槽进行绑定的。
        signal0&lt;&gt; ToSniffer;
        Topocation()
        {
            printf("Topocation is started!\n"); 
        }
        void startTopo()
        {
            cout &lt;&lt; "开始2" &lt;&lt; endl;
            ToSniffer();
            sleep(1);
            cout &lt;&lt; "结束2" &lt;&lt; endl;
        }

        // 继承 has_slots&lt;&gt; ，表示拥有响应信号的槽
};
class Sniffer : public has_slots&lt;&gt;
{
    public:
        Sniffer()
        {
        }
        // 作为信号响应的槽
        void startSniffer()
        {
            m_tx.lock();
            cout &lt;&lt; "开始探测！ " &lt;&lt; b_state &lt;&lt; endl;
            sleep(3);
            cout &lt;&lt;"探测结束" &lt;&lt; endl;
            m_tx.unlock();
        }
    private:
        bool b_state;
        ThreadMutex m_tx;
};
class Control
{
    private:
        pthread_t mythread;
    public:
        Sniffer mysniffer;
        Location myLoc;
        Topocation myTopo;
        Control()
        {
            myLoc.ToSniffer.connect(&amp;mysniffer,&amp;Sniffer::startSniffer);
            myTopo.ToSniffer.connect(&amp;mysniffer,&amp;Sniffer::startSniffer);
        }
        void controlsend()
        {
            int ret;
            //void *startFunc1(void *a);
            //void *p = (void *)a;
        void * startFunc1(void * tmp);
        void * startFunc2(void * tmp);
            ret = pthread_create(&amp;mythread,NULL,startFunc1,this);
            ret = pthread_create(&amp;mythread,NULL,startFunc2,this);
            if(ret &lt; 0)
                printf("thread create wrong!\n");
        }
};
        void * startFunc1(void * tmp)
        {
                Control * p = (Control *)tmp;
                    p -&gt;myLoc.startLoc();
        }
        void * startFunc2(void * tmp)
        {
                Control * p = (Control *)tmp;
                p -&gt; myTopo.startTopo();
        }
int main()
{

    int ret;
    Control mycontrol;
    mycontrol.controlsend();
    while(1);
    return 0;
}
</code></pre>

<p>Sniffer实现了 “槽” --- 即响应函数。<br/>
signal0&lt;> ToSniffer;<br/>
// 在这里指定信号，这里的信号是不带参数的，signaln表示带几个参数，后面将会用<br/>
        // 这个信号与指定的槽进行绑定的。
具体的用法可以查阅</p>

<pre><code>Sniffer mysniffer;
        Location myLoc;
        Topocation myTopo;
        Control()
        {
            myLoc.ToSniffer.connect(&amp;mysniffer,&amp;Sniffer::startSniffer);
            myTopo.ToSniffer.connect(&amp;mysniffer,&amp;Sniffer::startSniffer);
        }
</code></pre>

<p>在这里建立了链接。</p>

<p>可以用来实现 模块A 和B 调用公共模块。模块间省去了 用while循环的方式被动的接受命令，而是主动相应。while死循环的方式无疑是浪费cpu，而信号量的方式，又显得不够灵魂。
<strong>其实Sigslot也是封装了 观察者模式。</strong>这里需要特别注意拉。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>设计模式（五）  抽象工厂及各种工厂方法</title>
      <link href="/2012/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89--%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E5%8F%8A%E5%90%84%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
      <pubDate>2012-05-29T00:00:00+08:00</pubDate>
      <author>海涛</author>
      <guid>/2012/05/设计模式（五）--抽象工厂及各种工厂方法</guid>
      <content:encoded><![CDATA[<h2>设计模式（五） -- 抽象工厂及各种工厂总结</h2>

<h3>1.解释</h3>

<p>在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。我们依然拿生产汽车的例子来说明他们之间的区别。</p>

<p>其实感觉解释都是废话，还是看uml图 和代码吧。。</p>

<p>   <img src="http://www.cnblogs.com/images/cnblogs_com/zhenyulu/Pic46.gif" alt="enter image description here" /></p>

<pre><code>interface IProduct1 {
    public void show();
}
interface IProduct2 {
    public void show();
}

class Product1 implements IProduct1 {
    public void show() {
        System.out.println("这是1型产品");
    }
}
class Product2 implements IProduct2 {
    public void show() {
        System.out.println("这是2型产品");
    }
}

interface IFactory {
    public IProduct1 createProduct1();
    public IProduct2 createProduct2();
}
class Factory implements IFactory{
    public IProduct1 createProduct1() {
        return new Product1();
    }
    public IProduct2 createProduct2() {
        return new Product2();
    }
}

public class Client {
    public static void main(String[] args){
        IFactory factory = new Factory();
        factory.createProduct1().show();
        factory.createProduct2().show();
    }
}
</code></pre>

<p><strong>抽象工厂模式的优点</strong><br/>
        抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。</p>

<h3>2.工厂的比较</h3>

<p>引用：sopk00 对几个工厂的比较<br/>
<strong>个人感觉</strong><br/>
1. 简单工厂：工厂可以创建同一系列的产品，产品的接口一致，但工厂就要根据参数进行判断到底创建哪种产品
卖早饭的张婆婆：可以做茶叶蛋，包子，稀饭<br/>
2. 工厂方法：可以有多种工厂，工厂有共同的接口，一个工厂只能产生一种产品，比起简单工厂，工厂方法就不需要判断，耦合度低了不少
刘老板：只卖包子的包子铺，只卖稀饭的稀饭庄<br/>
3. 抽象工厂：可以产生多个系列的产品，有2个维度的产品
饮料店老板：可乐系列产品、咖啡系列产品，每种系列产品又分小杯、中杯、大杯</p>

<h3>3.应用</h3>

<p>引用jigenghua的话说：
在一个类里面, 当需要创建实例时:
01.如果只需创建一个实例, 直接用new, 直接高效, java初学者理应如此, 若用工厂模式, 小题大做, 故弄玄虚;</p>

<p>02.如果只需创建少量实例, 又想证实自己编程水平已过菜鸟级别, 可在单独一个小类中专门写new, new完记得返回新创建的引用给需求者, 这些new语句通常都是写在那个小类的单个静态方法中, 好处是调用时不用生成那个小类的实例, 而那个小类, 就是所谓的简单工厂模式;</p>

<p>03.如果要创建大量实例, 从类继承结构上来看, 这些实例都是同一个父亲,可以考虑用工厂方法模式.</p>

<p>04.如果要创建大量实例, 从类继承结构上来看, 这些实例有不同的父亲, 不管他们是否有相同的爷爷, 是不能采用工厂方法模式的, 得用抽象工厂模式. 这里, 抽象工厂模式的名称来由, 网上都是讳莫如深, 不要以为这种模式中加了一级抽象接口, 想当然就是抽象工厂模式, 须知工厂方法模式也是加了一级抽象接口的, 既然如此, 抽象工厂模式, 到底抽了谁们的象, 抽的又是什么象, 只可意会, 不可言传.
，从继承结构上来看这些实例的类：如果具有相同的父类，..</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
