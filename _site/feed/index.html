<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>海涛</title>
    <link href="/feed/" rel="self" />
    <link href="http://geeklu.com" />
    <lastBuildDate>2013-08-29T23:34:59+08:00</lastBuildDate>
    <webMaster>kejinlu@gmail.com</webMaster>
    
    <item>
      <title>阿里巴巴搜索技术总结</title>
      <link href="/2013/08/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
      <pubDate>2013-08-28T00:00:00+08:00</pubDate>
      <author>海涛</author>
      <guid>/2013/08/阿里巴巴搜索技术总结</guid>
      <content:encoded><![CDATA[<hr />

<h1>阿里巴巴搜索引擎技术大讲堂</h1>

<p> 今天结束了阿里巴巴<strong>搜索引擎</strong>的课程学习，通过两天的课程我可以说收获很多。 这也是我第一次用md语言来写博客。有点小兴奋哦，记录下时间，现在时刻是2013-08-28：23：26。呵呵</p>

<hr />

<h2>正文</h2>

<p> <strong>1，了解了阿里巴巴的搜索技术框架和各个细节。<br/>
2，了解了一个武侠公司的文化。<br/>
   3，对自己的兴趣爱好又有了更深入的了解，如：我知道了自己很喜欢架构这个东西。</strong></p>

<hr />

<h2>课程介绍</h2>

<hr />

<h3>1.1 一淘购物搜索全貌*一泉</h3>

<h3>1.2 全网商品Spider系统的关键技术*飘羽</h3>

<h3>1.3 基于Hadopp/HBase的一淘搜索离线系统*瓦力</h3>

<h3>1.4 商品检索引擎的关键技术*孝杰</h3>

<h3>1.5 Query的旅行--淘宝搜索在线系统*亚夫</h3>

<h3>2.1 啊里中文分词系统及电子商务环境中的文本挖掘*水德</h3>

<h3>2.2 淘宝个性化搜索*公达</h3>

<h3>2.3 一淘商品搜索相关性*亦飞</h3>

<h3>2.4 一淘产品库*倪完</h3>

<hr />
]]></content:encoded>
    </item>
    
    <item>
      <title>搜索全貌</title>
      <link href="/2013/08/%E6%90%9C%E7%B4%A2%E5%85%A8%E8%B2%8C/"/>
      <pubDate>2013-08-27T00:00:00+08:00</pubDate>
      <author>海涛</author>
      <guid>/2013/08/搜索全貌</guid>
      <content:encoded><![CDATA[<hr />

<h1>一淘搜索全貌</h1>

<p>一淘是整个啊里的搜索技术支持。</p>

<hr />

<h2>系统</h2>

<p>啊里整个搜索引擎可以分为四个部分。<br/>
1. <strong>引擎在线系统</strong>数千台服务器中美两地部署<br/>
2. <strong>Hadoop/Hbase离线集群</strong>规模和应用方式业界领先<br/>
3. <strong>商品快速更新</strong>能做到淘系/B2C商品信息变化在100s内更新到引擎<br/>
4. <strong>平台化/集中运维</strong>全系统平台化，开发成功共享，统一集中管理。</p>

<p>一淘搜索从2010年起步，到2011年部署hadoop/HBase（150台）到2013年的330台集群，更新率99.04%。</p>

<p>好了说了这么非技术的东西，现在上一个一淘搜索系统系统图
<img src="http://lgo.me/images/2013/08/29/IMG_20130827_103801.jpg" alt="enter image description here" /></p>

<p>从上图可以看出，存储系统的数据来源是分为外网抓取和淘宝商品库直接导入得来的。
有了大数据，下一步是进行“大数据处理”，接下来就是建立索引进行搜索了。</p>

<p><img src="http://hi.csdn.net/attachment/201108/20/0_1313816866b9b9.gif" alt="enter image description here" /></p>

<p>好的，如上图所示，我们可以看到，淘宝的海量数据产品技术架构，分为以下五个层次，从上至下来看，它们分别是：数据源，计算层，存储层，查询层和产品层。
这就是淘宝整个系统架构。</p>

<h4>我重点了解了</h4>

<p>QP： query planer 的作用。它是负责前台与后台传话。<br/>
Forest 内幕属性转化模块（主要负责前台的文本信息转换成数字标签）。</p>

<blockquote><p>用户输入查询词后，qp经过一定的分析，解析出后台应该可以识别的词。
这样Forest就可以将这些词，抓换成数字查询（数据库里商品的属性都是用数字来存储的，而建立这些数字与文字的对应关系的模块就是forest）。
转换的原因很容易想到，是因为数据库里面对整型数字的操作速度要方便快捷。</p></blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>程序崩溃的原因</title>
      <link href="/2013/06/%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <pubDate>2013-06-09T00:00:00+08:00</pubDate>
      <author>海涛</author>
      <guid>/2013/06/程序崩溃的原因</guid>
      <content:encoded><![CDATA[<h1>如果程序崩溃，可能的原因是什么？</h1>

<p>You are given the source to an application which crashes when it is run. After running
it ten times in a debugger, you find it never crashes in the same place. The application
is single threaded, and uses only the C standard library. What programming errors
could be causing this crash? How would you test each one?</p>

<p>大意：你得到一个应用的源码，该应用每次启动都会出现程序崩溃。再你调试了10次后发现，在一个相同的条件下，该程序从不崩溃。  该程序是单线程，并且使用的库函数是c的标准库。那么，该程序崩溃的原因是什么？你怎样检测它呢？</p>

<p>The question largely depends on the type of application being diagnosed. However, we can
give some general causes of random crashes.
1. Random variable: The application uses some random number or variable component
   which may not be fixed for every execution of the program. Examples include: user
  input, a random number generated by the program, or the time of day.
2. Memory Leak: The program may have run out of memory. Other culprits are totally
   random for each run since it depends on the number of processes running at that
  particular time. This also includes heap overflow or corruption of data on the stack.
It is also possible that the program depends on another application / external module that
could lead to the crash. If our application, for example, depends on some system attributes
and they are modified by another program, then this interference may lead to a crash. Pro-
grams which interact with hardware are more prone to these errors.
In an interview, we should ask about which kind of application is being run. This information
may give you some idea about the kind of error the interviewer is looking for. For example,
a web server is more prone to memory leakage, whereas a program that runs close to the
system level is more prone to crashes due to system dependencies.</p>

<p>答案：该问题很大程度上取决于对该应用的诊断。但我们可以总结一下一些随机常见的崩溃原因：</p>

<ol>
<li>不确定的变量：程序使用了随机的数字或变量组件，在程序执行时没有被很好的确定范围。如：用户输入，随机数，或时间。</li>
</ol>


<p>2.内存泄漏：程序每次执行时都内存溢出。每次运行程序崩溃的罪魁祸首是随机的，因为它依赖于在特定时间运行的进程数。</p>

<p>包括堆溢出或者是栈异常。
程序依赖于其它外部应用也可能导致崩溃。如果我们的应用依赖于一个系统某些系统属性，他们被另一个程序修改，那么这个干扰可能会导致系统崩溃。与硬件交互的程序更容易出现这些错误。例如，一个Web服务器是更容易出现内存泄漏，而接近系统级运行的程序更容易崩溃，由于系统的依赖。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>设计模式开篇（一）</title>
      <link href="/2012/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BC%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <pubDate>2012-04-23T00:00:00+08:00</pubDate>
      <author>海涛</author>
      <guid>/2012/04/设计模式开篇（一）</guid>
      <content:encoded><![CDATA[<h2>设计模式开篇（一）</h2>

<p>已经有很多前辈写过关于设计模式的很多经典文章，我在这里记录一些自己的学习进程，表示自己还在学习好了。</p>

<p>先从借来的大话设计模式看起，今天是第一章和第二章。</p>

<h2>第一章 简单uml</h2>

<p>uml中继承很容易记住。</p>

<p>说些不怎么好记住的，如 依赖 ，关联 ，聚合，组合 。</p>

<p>依赖用 虚线箭头表示，在代码上是类的方法用到（传入或引用）了 被依赖的类。</p>

<p><strong>关联：</strong>有名的客户和订单的关系以及公司和员工的关系，都是关联关系。还有就是我和我的单车的例子，他们都是一种“拥有”的关系。表现在代码上，就是一个类包含另一个类的实例，通常表现为被关联类以类属性的形式出现在关联类的类定义中，也可以表现为关联类引用了一个类型为被关联类的全局变量。关联可以使单向的，也可以使双向的。</p>

<pre><code>public class Company
{
    private Employee employee;
    public Employee GetEmployee()
    {
        return employee;
    }
    public void SetEmployee(Employee employee)
    {
        this.employee = employee;
    }
    //公司运作    
    public void Run()
    {
        employee.StartWorking();
    }

}
</code></pre>

<p><strong>聚合</strong></p>

<p>聚合(aggregation)是一种特殊的联系，它表明了“部分”到“整体”的关系，显著的特点就是不能包含循环的联系（就是说，部分中不能包含整体）。如：<br/>
<img src="http://tech.idv2.com/wp-content/uploads/2009/04/uml-aac-diff-02.png" alt="enter image description here" /></p>

<p>class Node
{
private:
vector&lt;Node*> itsNodes;
};
上述代码只有当子节点不会成为父节点的父节点时（即，必须是树结构，不能是图结构），才能称之为聚合。</p>

<p><strong>组合</strong></p>

<p>组合(composition)跟聚合几乎相同，唯一的区别就是“部分”不能脱离“整体”单独存在，就是说， “部分”的生命期不能比“整体”还要长。例如：<br/>
<img src="http://tech.idv2.com/wp-content/uploads/2009/04/uml-aac-diff-03.png" alt="enter image description here" /></p>

<pre><code>class Car
{
public:
virtual ~Car() {delete itsCarb;}
private:
Carburetor* itsCarb
};
</code></pre>

<p><strong>聚合</strong>和<strong>组合</strong>区别：用C++程序的话,聚合就像是类中的指针成员,而组合就是类中的成员。需要该类来创建对象。//这里说的应该不是很准确</p>

<p>关联与依赖的区别：有说“关联本身即是一种依赖”，亦有说“依赖是一种弱关联”，其实说来说去是一档子事。依赖和关联都是说一个类用到了另一个类。其区别在于一个是使用，一个是拥有。</p>

<p>关联和聚合 的区别是： 聚合是一对多的。而关联貌似是一对一的。 关联只有一个类知道另外一个类的公共属性和操作。包含了另一个对象的引用。 而聚合则是拥有被聚合类的指针，要在<strong>非成员方法</strong>里面使用。</p>

<p><strong>总结一下：
依赖、关联、聚合、组合、继承、实现 耦合度依次提高。</strong></p>

<p>区分心法：</p>

<p>1.成员变量中没有B类，方法中使用，则为依赖。</p>

<p>2.成员变量中有B类的引用或指针，并不参与B对象的构建，则是关联。</p>

<p>3.成员变量中有B类的指针，方法中使用，则是聚合关系。</p>

<p>4.成员变量或构造函数中有B类的实现对象，则是组合。</p>

<h2>第二章 工厂模式和策略模式</h2>

<p>工厂模式用到的是依赖模式的关系。<br/>
<img src="http://woniu1983.iteye.com/upload/picture/pic/66033/2077c228-8bbc-3b6e-a416-072e75e1d638.jpg" alt="enter image description here" /></p>

<p>而策略模式用到的是聚合模式。</p>

<p><img src="http://www.blue1000.com/upload/2008_07/080709174345591.jpg" alt="enter image description here" /></p>

<p>策 略模式是一种第一一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。并且继承类有助于定义一系列可供重复用的算法或行为。每个算法都有自己单独的类可以单独测试。</p>

<p>与工厂结合可以简化客户端，将具体的实现转移到策略模式中。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>RPC通信机制</title>
      <link href="/2011/05/RPC%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/"/>
      <pubDate>2011-05-10T00:00:00+08:00</pubDate>
      <author>海涛</author>
      <guid>/2011/05/RPC通信机制</guid>
      <content:encoded><![CDATA[<hr />

<h1>“RPC”通信机制</h1>

<p>今天得到一个名字叫“RPC”通信机制，这是什么东西呢？
Hadoop的IPC是实现rpc的一种方法，不基于java的序列化机制。IPC中方法的调用参数和返回值只能是:</p>

<p>1、java基本类型<br/>
2、String和Writeable接口的实现类<br/>
3、以1、2元素为类型的数组<br/>
4、接口只允许抛出IOException</p>

<blockquote><p>原来hadoop也是使用RPC通信模式的。<br/>
<strong>google一下解释直接贴过来：</strong></p></blockquote>

<h3>1、RPC（Remote Procedure Call Protocol）</h3>

<p>RPC(Remote Procedure Call,远程过程调用)是建立在Socket之上的,出于一种类比的愿望,在一台机器上运行的主程序,可以调用远程另一套机器上的子程序,就像LPC(本地过程调用).</p>

<p><strong>越底层,代码越复杂,灵活性越高,效率越高; 越上层,抽象封装的越好,代码越简单,效率越差.</strong> Socket和RPC的区别再次说明了这点.
rpc封装了socket是属于上层的应用。
一、RPC概述
第一节、RPC结构网络
RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。</p>

<p>RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息的到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p>

<p>   目前，有多种 RPC 模式和执行。最初由 Sun 公司提出。IETF ONC 宪章重新修订了 Sun 版本，使得 ONC RPC 协议成为 IETF 标准协议。现在使用最普遍的模式和执行是开放式软件基础的分布式计算环境（DCE）。</p>

<h3>第二节、协议结构</h3>

<p>远程过程调用（RPC）信息协议由两个不同结构组成：调用信息和答复信息。信息流程如下所示：</p>

<p>　　RPC：远程过程调用流程</p>

<p>　　RPC 调用信息：每条远程过程调用信息包括以下无符号整数字段，以独立识别远程过程：</p>

<p>　　程序号（Program number）</p>

<p>　　程序版本号（Program version number）</p>

<p>　　过程号（Procedure number）</p>

<p>　　RPC 调用信息主体形式如下：</p>

<pre><code>c:
 struct call_body {

unsigned int rpcvers;

unsigned int prog;

unsigned int vers;

unsigned int proc;

opaque_auth cred;

opaque_auth verf;

1 parameter

2 parameter . . . }；
</code></pre>

<p>　　RPC 答复信息：RPC 协议的答复信息的改变取决于网络服务器对调用信息是接收还是拒绝。答复信息请求包括区别以下情形的各种信息：</p>

<p>　　RPC 成功执行调用信息。.</p>

<p>　 RPC 的远程实现不是协议第二版，返回 RPC 支持的最低和最高版本号。</p>

<p>　　在远程系统中，远程程序不可用。</p>

<p>　　远程程序不支持被请求的版本号。返回远程程序所支持的最低和最高版本号。</p>

<p>　　请求的过程号不存在。通常是呼叫方协议或程序差错。</p>

<p>　　RPC答复信息形式如下：</p>

<pre><code>enum reply_stat stat

{MSG_ACCEPTED = 0,

MSG_DENIED = 1 }；
</code></pre>

<h3>第三节、工作原理</h3>

<p>运行时,一次客户机对服务器的RPC调用,其内部操作大致有如下十步：</p>

<p>　　1.调用客户端句柄；执行传送参数</p>

<p>　　2.调用本地系统内核发送网络消息</p>

<p>　　3.消息传送到远程主机</p>

<p>　　4.服务器句柄得到消息并取得参数</p>

<p>　　5.执行远程过程</p>

<p>　　6.执行的过程将结果返回服务器句柄</p>

<p>　　7.服务器句柄返回结果，调用远程系统内核</p>

<p>　　8.消息传回本地主机</p>

<p>　　9.客户句柄由内核接收消息</p>

<p>　　10.客户接收句柄返回的数据</p>

<h3>第四节、RPC OVER HTTP</h3>

<p>Microsoft RPC-over-HTTP 部署(RPC over HTTP)允许RPC 客户端安全和有效地通过Internet 连接到RPC 服务器程序并执行远程过程调用。这是在一个名称为RPC-over-HTTP 代理，或简称为RPC 代理的中间件的帮助下完成的。</p>

<p>RPC 代理运行在IIS 计算机上。它接受来自Internet 的RPC 请求，在这些请求上执行认证，检验和访问检查，如果请求通过所有的测试，RPC 代理将请求转发给执行真正处理的RPC 服务器。通过RPC over HTTP，RPC 客户端不和服务器直接通信，它们使用RPC 代理作为中间件。</p>

<p>具体怎么用，还是要工程（分布式）实践中使用了。</p>

<hr />
]]></content:encoded>
    </item>
    
  </channel>
</rss>
